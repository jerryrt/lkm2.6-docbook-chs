<sect1><title>什么是内核模块？</title>

	<para>现在，你是不是想编写内核模块。你应该懂得C语言，写过一些用户程序， 那么现在你将要见识一些真实的东西。在这里，你会看到一个野蛮的指针是如何 毁掉你的文件系统的，一次内核崩溃意味着重启动。</para>

	<para>什么是内核模块？内核模块是一些可以让操作系统内核在需要时载入和执 行的代码，这同样意味着它可以在不需要时有操作系统卸载。它们扩展了操作系 统内核的功能却不需要重新启动系统。举例子来说，其中一种内核模块时设备驱 动程序模块，它们用来让操作系统正确识别，使用安装在系统上的硬件设备。如 果没有内核模块，我们不得不一次又一次重新编译生成单内核操作系统的内核镜 像来加入新的功能。这还意味着一个臃肿的内核。</para>

</sect1>



<sect1><title>内核模块是如何被调入内核工作的？</title>

	<indexterm><primary>/proc/modules</primary></indexterm>
	<indexterm><primary>kmod</primary></indexterm>
	<indexterm><primary>kerneld</primary></indexterm>
	<indexterm><primary><filename>/etc/modules.conf</filename></primary></indexterm>
	<indexterm><primary><filename>/etc/conf.modules</filename></primary></indexterm>

	<para>你可以通过执行<command>lsmod</command>命令来查看内核已经加载了哪
	些内核模块, 该命令通过读取<filename>/proc/modules</filename>文件的内容
	来获得所需信息。</para>

	<para>这些内核模块是如何被调入内核的？当操作系统内核需要的扩展功能不存
	在时，内核模块管理守护进程kmod<footnote><para>在早期的linux版本中，是
	一个名为kerneld的守护进程。</para></footnote>执行modprobe去加载内核模
	块。两种类型的参数被传递给modprobe：</para>

	<itemizedlist>
	<listitem>一个内核模块的名字像<filename>softdog</filename>或是<filename>ppp</filename>。
	</listitem>
	<listitem>通用识别符像<varname>char-major-10-30</varname>。</listitem>
	</itemizedlist>

	<para>当传递给modprobe是通用识别符时，modprobe首先在文件
	<filename>/etc/modules.conf</filename>查找该字符串。如果它发现的一行别名像：
	</para>
	
	<screen>
alias char-major-10-30 softdog
	</screen>

	<para>它就明白通用识别符是指向内核模块<filename>softdog.o</filename>。</para>

	<para>然后，modprobe遍历文件<filename>/lib/modules/version/modules.dep</filename>
	来判断是否有其它内核模块需要在该模块加载前被加载。该文件是由命令<command>depmod -a</command>
	建立，保存着内核模块的依赖关系。举例来说，<filename>msdos.o</filename>依赖于模块<filename>fat.o</filename>
	内核模块已经被内核载入。当要加载的内核模块需要使用别的模块提供的符号链接时（多半是变量或函数），
	那么那些提供这些所需符号链接的内核模块就被该模块所依赖。</para>

	<para>最终，modprobe调用insmod先加载被依赖的模块，然后加载该被内核要求的模块。modprobe将insmod指向
	<filename role="directory">/lib/modules/version/</filename><footnote><para>如果你在修改内核，为避免
	覆盖你现在工作的模块，你应该试试使用内核Makefile中的变量<varname>EXTRAVERSION</varname>去建立一个独
	立的模块目录。 </para></footnote>目录，该目录为默认标准存放内核模块的目录。insmod对内核模块存放位置
	的处理相当呆板，所以modprobe应该很清楚的知道默认标准的内核模块存放的位置。所以，当你想要载入一个内
	核模块时，你可以执行：</para>

	<screen>
insmod /lib/modules/2.5.1/kernel/fs/fat/fat.o
insmod /lib/modules/2.5.1/kernel/fs/msdos/msdos.o
	</screen>
	
	<para>或只是执行"<command>modprobe -a msdos</command>"。</para>

	<indexterm><primary>modules.conf</primary><secondary>keep</secondary></indexterm>
	<indexterm><primary>modules.conf</primary><secondary>comment</secondary></indexterm>
	<indexterm><primary>modules.conf</primary><secondary>alias</secondary></indexterm>
	<indexterm><primary>modules.conf</primary><secondary>options</secondary></indexterm>
	<indexterm><primary>modules.conf</primary><secondary>path</secondary></indexterm>


	<para>Linux提供modprobe, insmod and depmod在一个名为modutils 或 mod-utils的工具包内。</para>

	<para>在结束本章前，让我们来看一个 <filename>/etc/modules.conf</filename>文件：</para>

	<screen>
#This file is automatically generated by update-modules
path[misc]=/lib/modules/2.4.?/local
keep
path[net]=~p/mymodules
options mydriver irq=10
alias eth0 eepro
	</screen>

	<para>用'#'起始的行为注释。空白行被忽略。</para>
	
	<para>以 <literal>path[misc]</literal>起始的行告诉modprobe用
	<filename role="directory">/lib/modules/2.4.?/local</filename>替代搜寻
	misc内核模块的路径。正如你看到的，命令解释器shell的元字符也可以使用。</para>

	<para>以<literal>path[net]</literal>起始的行告诉modprobe 在目录 <filename role="directory">
	~p/mymodules</filename>搜索网络方面的内核模块。但是，在<literal>path[net]</literal>
	指令之前使用的"keep" 指令告诉modprobe只是将该路径添加到标准搜索路径中，而不是像对待
	misc前面那样进行替换。</para>

	<para>以alias 起始的的行使modprobe加载<filename>eepro.o</filename>当kmod 以通用识别符'eth0'
	要求加载相应内核模块时。</para>

	<para>你不会发现像"alias block-major-2 floppy"这样的别名行在文件<filename>/etc/modules.conf
	</filename> 因为modprobe已经知道在绝大多数系统上安装的标准的设备的驱动模块。</para>

	<para>现在你已经知道内核模块是如何被调入的了。当你想写你自己的依赖于其它模块的内核模块时，
	还有一些内容没有提供。这个相对高级的问题将在以后的章节中介绍，当我们已经完成前面的学习后。
	</para>



		<sect2><title>在开始前</title>

			<para>在我们介绍源代码前，有一些事需要注意。系统彼此之间的不同会导致许多困难。
			顺利的编译并且加载你的第一个"hello world"模块有时就会比较困难。但是当你跨过
			这道坎时，后面会顺利的多。</para>



				<sect3><title>内核模块和内核的版本问题</title>

					<para>为某个版本编译的模块将不能被另一个版本的内核加载如果内核中打开了
					<literal>CONFIG_MODVERSIONS</literal>选项。我们暂时不会讨论与此相关的
					内容。在我们进入相关内容前，本文档中的范例可能在该选项打开的情况下无法
					工作。但是，目前绝大多数的发行版是将该选项打开的。所以如果你遇到和版本
					相关的错误时，最好，重新编译一个关闭该选项的内核。</para>

				</sect3>



				<sect3 id="usingx"><title>使用 X带来的问题</title>

					<para>强烈建议你在控制台下输入文档中的范例代码，编译然后加载模块，而不是在X下。</para>

					<para>模块不能像<function>printf()</function>那样输出到屏幕，但它们可以
					记录信息和警告，当且仅当你在使用控制台时这些信息才能最终显示在屏幕上。
					如果你从xterm中insmod一个模块，这些日志信息只会记录在你的日志文件中。
					除了查看日志文件你将无法 得到输出信息。想要及时的获得这些日志信息，建议
					所有的工作都在控制台下进行。</para>

				</sect3>



				<sect3><title>编译相关和内核版本相关的问题</title>

					<para>Linux的发行版经常给内核打一些非标准的补丁，这种情况回导致一些问题的发生。</para>

					<para>一个更普遍的问题是一些Linux发行版提供的头文件不完整。编译模块时你将需要非常多
					的内核头文件。墨菲法则之一就是那些缺少的头文件恰恰是你最需要的。</para>

					<para>我强烈建议从Linux镜像站点下载源代码包，编译新内核并用新内核启动系统来避免以上
					的问题。参阅"Linux Kernel HOWTO"获得详细内容。</para>

					<para>具有讽刺意味的是，这也会导致一些问题。gcc倾向于在缺省的内核源文件路径(通常是<filename
					role="directory">/usr/src/</filename>)下寻找源代码文件。这可以通过gcc的<literal>-I</literal>
					选项来切换。</para>
					
				</sect3>	

		</sect2>

</sect1>



<!--
vim: tw=128
-->
