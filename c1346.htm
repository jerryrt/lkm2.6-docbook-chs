<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Symmetric Multi Processing</TITLE
><META CHARSET="UTF-8"><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="The Linux Kernel Module Programming Guide"
HREF="book1.htm"><LINK
REL="PREVIOUS"
TITLE="Interrupt Handlers"
HREF="c1265.htm"><LINK
REL="NEXT"
TITLE="Common Pitfalls"
HREF="c1373.htm"></HEAD
><BODY
CLASS="CHAPTER"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>The Linux Kernel Module Programming Guide</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c1265.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c1373.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="CHAPTER"
><H1
><A
NAME="AEN1346"
></A
>Chapter 13. Symmetric Multi Processing</H1
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AEN1348"
>对称多线程处理</A
></H1
><A
NAME="AEN1350"
></A
><A
NAME="AEN1352"
></A
><A
NAME="AEN1354"
></A
><A
NAME="AEN1356"
></A
><A
NAME="AEN1359"
></A
><P
>提高性能的最简单也是最便宜的方法是给你的主板加第二个CPU（如果你的主板支持的话）。
	这可以通过让不同的CPU完成不同的工作（非对称多线程处理）或是相同的工作（对称多线程处理）。
	实现高效率的非对称的多线程处理需要特殊硬件相关的知识，而对于Linux这样通用操作系统这是不可能的。
	相对而言，对称多线程处理是较容易实现的。</P
><P
>我这里所说的相对容易，老实说，还是不容易。在一个对称多线程处理的环境中，
	多个CPU共享内存，导致的结果是其中一个CPU运行的代码会对别的CPU也产生影响。
	你不能再确定你代码中第一行中设置的变量在接下来的那行代码中还是那个设置值；
	其它的CPU可能会趁你不注意已经把它修改了。显然，如果是这样的话，是无法进行任何编程的。
	</P
><P
>对于进程层面上的编程这通常不是个问题，因为一个进程通常同一时间只在一个CPU上运行
	<A
NAME="AEN1365"
HREF="#FTN.AEN1365"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>。
	但是，对于内核，就可以被在不同的CPU上的同时运行的不同的进程使用。</P
><P
>在内核版本2.0.x中，这还不算作什么问题，因为整个内核是一个spinlock
	<A
NAME="AEN1368"
HREF="#FTN.AEN1368"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
>，这就意味着一旦某个CPU进入内核态，别的CPU将不允许进入内核态。这使Linux的SMP实现很安全
	<A
NAME="AEN1370"
HREF="#FTN.AEN1370"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
>，但缺乏效率。</P
><P
>在内核版本2.2.x以后，多CPU已经允许同时进入内核态。内核模块的作者应该意识到这一点。</P
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1365"
HREF="c1346.htm#AEN1365"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>存在例外，就是线程化的进程，这样的进程可以在多个CPU上同时运行。</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1368"
HREF="c1346.htm#AEN1368"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>抱歉，我没有找到合适的词语来表达这个单词。这是内核中的一种机制，可以对内核中的关键数据结构进行锁定保护，
	防止其被破坏。</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN1370"
HREF="c1346.htm#AEN1370"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>意味着这样的SMP机制使用起来很安全。</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c1265.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.htm"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c1373.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Interrupt Handlers</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Common Pitfalls</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>